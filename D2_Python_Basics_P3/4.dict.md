In **Machine Learning (ML)**, Dictionaries are the gold standard for storing **hyperparameters**, **model configurations**, and **JSON metadata**. In **Competitive Programming (CP)**, they are your **HashMaps**, providing **O(1)** time complexity for lookups, making them essential for frequency counting and the "Two-Sum" pattern.

---

## ðŸ“– Dictionaries: The Power of HashMaps

A dictionary is a collection of `key: value` pairs. Keys must be **unique** and **immutable** (like strings, numbers, or tuples).

### 1. Essential Methods for ML & CP

* **`.get(key, default)`**: The "Safe Access" method. If the key is missing, it returns the `default` value instead of crashing with a `KeyError`.
* **`.items()`**: Returns a view of all key-value pairs. Used constantly to loop through model parameters.
* **`.keys()` / `.values()**`: Returns only the keys or only the values.
* **`.update({key: value})`**: Merges another dictionary or updates existing values.

```python
# ML Example: Model Hyperparameters
config = {"lr": 0.01, "batch_size": 32}

# 1. Safe Access
print(config.get("epochs", 10)) # Returns 10 because 'epochs' isn't set

# 2. Updating values
config.update({"lr": 0.001, "optimizer": "Adam"})

# 3. Iterating (Common in ML training loops)
for param, val in config.items():
    print(f"{param}: {val}")

```

---

### 2. Dictionary Comprehensions

Just like lists, you can build dictionaries in one line. This is great for mapping feature names to indices.

```python
features = ['age', 'income', 'zipcode']

# Creating a mapping: {feature_name: index}
feature_map = {name: i for i, name in enumerate(features)}
# Output: {'age': 0, 'income': 1, 'zipcode': 2}

```

---

### 3. The "Power User" Tools (`collections` module)

In CP and NLP (Natural Language Processing), these two variants are game-changers:

#### A. `defaultdict`

Eliminates the need to check if a key exists before adding to it.

* **CP Use Case:** Building an adjacency list for a Graph.

```python
from collections import defaultdict

# Initialize with 'list' as the default value
graph = defaultdict(list)
graph['node_A'].append('node_B') # No KeyError!

```

#### B. `Counter`

A high-performance frequency map.

* **ML Use Case:** Counting class distributions in your target variable.

```python
from collections import Counter

labels = ['cat', 'dog', 'cat', 'cat', 'bird']
counts = Counter(labels)
print(counts.most_common(1)) # Output: [('cat', 3)]

```

---

### 4. Performance Summary (Markdown Optimized)

| Operation | Time Complexity | Note |
| --- | --- | --- |
| **Access** | **O(1)** | Using `dict[key]` or `.get()` |
| **Insertion** | **O(1)** | Adding a new key-value pair |
| **Deletion** | **O(1)** | Using `del` or `.pop()` |
| **Search (Key)** | **O(1)** | `if key in dict:` |

---

### ðŸ’¡ Pro-Tip for CP: `dict.fromkeys()`

If you need to initialize a dictionary with a list of keys and a shared default value (like 0), use `fromkeys`:

```python
keys = ['a', 'b', 'c']
new_dict = dict.fromkeys(keys, 0) # {'a': 0, 'b': 0, 'c': 0}

```

---
