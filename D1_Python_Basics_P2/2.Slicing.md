
```python
import numpy as np
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Slice syntax: [rows, columns]
# Get the first two rows and the last two columns
sub_matrix = matrix[:2, 1:] 
# Result: [[2, 3], [5, 6]]

```

### Comparison Table for Quick Reference

| Requirement | Syntax | Use Case |
| --- | --- | --- |
| **All features except label** | `X = data[:, :-1]` | ML Model Training |
| **Only the target label** | `y = data[:, -1]` | ML Model Training |
| **Reverse an array** | `arr[::-1]` | Competitive Coding |
| **Downsample by 2x** | `arr[::2]` | Signal/Image Processing |

---

## Pro-Tip for CP: `slice()` Object

Sometimes you want to store a slice pattern and reuse it. Python has a built-in `slice` function.

```python
# Instead of hardcoding [1:5]
my_rule = slice(1, 5)
print(my_list[my_rule])

```

> **Wait!** Before we move on, remember: Slicing in Python creates a **shallow copy** for lists, but in NumPy, it creates a **view**. This means if you change a slice in NumPy, the original data changes too!



That is a critical distinction! If you miss this in Machine Learning, you might accidentally "corrupt" your original dataset while trying to normalize a subset of it.

Let's look at the two behaviors side-by-side.

---

### 1. Python Lists: The "Snapshot" (Shallow Copy)

When you slice a standard Python list, Python creates a **new list object** containing the same elements. Modifying the slice does **not** affect the original.

```python
# Standard Python List
original_list = [10, 20, 30, 40, 50]
slice_list = original_list[1:4]  # [20, 30, 40]

# Modify the slice
slice_list[0] = 999

print(f"Slice: {slice_list}")      # [999, 30, 40]
print(f"Original: {original_list}") # [10, 20, 30, 40, 50] (Unchanged!)

```

---

### 2. NumPy Arrays: The "Window" (View)

NumPy is designed for high performance and memory efficiency. Instead of copying large datasets (which could be gigabytes in size), NumPy slicing gives you a **view** of the original memory.

```python
import numpy as np

# NumPy Array
original_np = np.array([10, 20, 30, 40, 50])
view_np = original_np[1:4]  # [20, 30, 40]

# Modify the view
view_np[0] = 999

print(f"View: {view_np}")          # [999, 30, 40]
print(f"Original: {original_np}")   # [10, 999, 30, 40, 50] (CHANGED!)

```

### Why this matters for ML:

If you are working on a project and you slice out your "Validation Set" using NumPy/Pandas, and then you perform an operation like `val_set += 1`, you have just modified your **entire underlying dataset**.

**The Fix:** If you need a completely independent copy in NumPy, you must explicitly use `.copy()`:

```python
independent_copy = original_np[1:4].copy()

```

---

### Practice Challenge

Try to predict the output of this snippet (Competitive Coding Style):

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
subset = arr[:, 1]
subset[:] = 0
# What does 'arr' look like now?

