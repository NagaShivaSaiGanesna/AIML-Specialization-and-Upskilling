# Building a Simple Flask Web Application: The Basic Skeleton

This guide covers the fundamental structure required to start a Flask project. We will walk through setting up the environment, initializing the application, and creating web routes.

---

## 1. Environment Setup

Before writing any code, you must ensure that the Flask library is installed in your Python environment. The professional standard is to use a `requirements.txt` file to manage dependencies.

### Installation Steps:

1. Create a file named `requirements.txt` and add the word `flask`.
2. Open your terminal or command prompt.
3. Run the following command to install the library:
```bash
pip install -r requirements.txt

```



---

## 2. The Flask Application Skeleton

Every Flask project follows a specific structural pattern. Below is the minimum viable code required to get a server running.

### Basic Implementation (`app.py`)

```python
from flask import Flask

# Initialize the Flask application
app = Flask(__name__)

@app.route("/")
def welcome():
    return "Welcome to this Flask course! This is the home page."

if __name__ == "__main__":
    app.run(debug=True)

```

### Breaking Down the Components:

* **`app = Flask(__name__)`**: This line creates an instance of the `Flask` class. This instance serves as our **WSGI (Web Server Gateway Interface)** application. The `__name__` parameter helps Flask determine the root path of the application so it can find resources like templates and static files.
* **`if __name__ == "__main__":`**: This is the standard Python entry point. It ensures that the server only starts if the script is executed directly (e.g., `python app.py`) and not when imported as a module in another script.
* **`app.run()`**: This method launches the local development server.

---

## 3. Understanding Routing and Decorators

In Flask, **Routing** is the process of mapping a URL (Uniform Resource Locator) to a specific Python function. This is achieved using **Decorators**.

### The `@app.route()` Decorator

A decorator is a function that wraps another function to modify its behavior. In Flask, `@app.route("/path")` tells the application: *"When a user visits this specific URL path, execute the function immediately following this decorator."*

### Creating Multiple Routes

You can define multiple routes to handle different pages of your website. Each route must have a **unique function name**.

| URL Path | Function Name | Purpose |
| --- | --- | --- |
| `/` | `welcome()` | The root/home page of the site. |
| `/index` | `index()` | A secondary index or landing page. |
| `/contact` | `contact()` | A page for contact information. |

---

## 4. Enhanced Development with `debug=True`

When running your application using `app.run()`, you can pass several parameters to customize the behavior of the server.

### The Debug Mode

By default, if you make a change to your code, you must manually stop and restart the server to see the updates. By setting `debug=True`, you enable two powerful features:

1. **Auto-Reloader:** The server automatically detects code changes and restarts itself.
2. **Interactive Debugger:** If an error occurs in your code, the browser will display a detailed stack trace to help you troubleshoot.

### Customizing Host and Port

You can also specify where the app runs:

```python
# Running on a specific port (e.g., 8080)
app.run(host="0.0.0.0", port=8080, debug=True)

```

* `host="0.0.0.0"`: Makes the server accessible on your local network.
* `port=8080`: Changes the default port from `5000` to `8080`.

---

## Summary of Workflow

1. **Initialize** the app using `app = Flask(__name__)`.
2. **Define routes** using the `@app.route()` decorator.
3. **Create view functions** that return the content (strings, HTML, etc.) you want the user to see.
4. **Execute** the script using `python app.py` to start the development server.

